import Redis from 'ioredis';

export interface CacheOptions {
  ttl?: number; // Time to live in seconds
  prefix?: string; // Cache key prefix
}

export interface CacheStats {
  hits: number;
  misses: number;
  keys: number;
  memory: number;
  hitRate: number;
}

export class RedisService {
  private static instance: RedisService;
  private redis: Redis;
  private stats = {
    hits: 0,
    misses: 0
  };

  private constructor() {
    const redisUrl = process.env.REDIS_URL || 'redis://redis:6379';

    this.redis = new Redis(redisUrl, {
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
      lazyConnect: true
    });

    this.redis.on('connect', () => {
      console.log('🔗 Connected to Redis');
    });

    this.redis.on('error', (err) => {
      console.error('❌ Redis connection error:', err);
    });

    this.redis.on('ready', () => {
      console.log('✅ Redis is ready');
    });

    this.redis.on('close', () => {
      console.log('🔌 Redis connection closed');
    });
  }

  public static getInstance(): RedisService {
    if (!RedisService.instance) {
      RedisService.instance = new RedisService();
    }
    return RedisService.instance;
  }

  // Basic cache operations
  public async get<T>(key: string, options?: CacheOptions): Promise<T | null> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const value = await this.redis.get(fullKey);

      if (value !== null) {
        this.stats.hits++;
        return JSON.parse(value);
      } else {
        this.stats.misses++;
        return null;
      }
    } catch (error) {
      console.error(`Redis GET error for key ${key}:`, error);
      return null;
    }
  }

  public async set<T>(key: string, value: T, options?: CacheOptions): Promise<boolean> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const serializedValue = JSON.stringify(value);

      if (options?.ttl) {
        await this.redis.setex(fullKey, options.ttl, serializedValue);
      } else {
        await this.redis.set(fullKey, serializedValue);
      }

      return true;
    } catch (error) {
      console.error(`Redis SET error for key ${key}:`, error);
      return false;
    }
  }

  public async del(key: string | string[], options?: CacheOptions): Promise<boolean> {
    try {
      const keys = Array.isArray(key) ? key : [key];
      const fullKeys = keys.map(k => this.buildKey(k, options?.prefix));

      await this.redis.del(...fullKeys);
      return true;
    } catch (error) {
      console.error(`Redis DEL error:`, error);
      return false;
    }
  }

  public async exists(key: string, options?: CacheOptions): Promise<boolean> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const exists = await this.redis.exists(fullKey);
      return exists === 1;
    } catch (error) {
      console.error(`Redis EXISTS error for key ${key}:`, error);
      return false;
    }
  }

  public async expire(key: string, seconds: number, options?: CacheOptions): Promise<boolean> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const result = await this.redis.expire(fullKey, seconds);
      return result === 1;
    } catch (error) {
      console.error(`Redis EXPIRE error for key ${key}:`, error);
      return false;
    }
  }

  // Advanced cache operations
  public async getOrSet<T>(
    key: string,
    fetchFunction: () => Promise<T>,
    options?: CacheOptions
  ): Promise<T> {
    const cachedValue = await this.get<T>(key, options);

    if (cachedValue !== null) {
      return cachedValue;
    }

    const value = await fetchFunction();
    await this.set(key, value, options);
    return value;
  }

  public async mget<T>(keys: string[], options?: CacheOptions): Promise<(T | null)[]> {
    try {
      const fullKeys = keys.map(key => this.buildKey(key, options?.prefix));
      const values = await this.redis.mget(...fullKeys);

      return values.map(value => {
        if (value !== null) {
          this.stats.hits++;
          return JSON.parse(value);
        } else {
          this.stats.misses++;
          return null;
        }
      });
    } catch (error) {
      console.error(`Redis MGET error:`, error);
      return keys.map(() => null);
    }
  }

  public async mset(keyValuePairs: Array<{ key: string; value: any }>, options?: CacheOptions): Promise<boolean> {
    try {
      const pipeline = this.redis.pipeline();

      keyValuePairs.forEach(({ key, value }) => {
        const fullKey = this.buildKey(key, options?.prefix);
        const serializedValue = JSON.stringify(value);

        if (options?.ttl) {
          pipeline.setex(fullKey, options.ttl, serializedValue);
        } else {
          pipeline.set(fullKey, serializedValue);
        }
      });

      await pipeline.exec();
      return true;
    } catch (error) {
      console.error(`Redis MSET error:`, error);
      return false;
    }
  }

  // Hash operations
  public async hget<T>(hash: string, field: string, options?: CacheOptions): Promise<T | null> {
    try {
      const fullHash = this.buildKey(hash, options?.prefix);
      const value = await this.redis.hget(fullHash, field);

      if (value !== null) {
        this.stats.hits++;
        return JSON.parse(value);
      } else {
        this.stats.misses++;
        return null;
      }
    } catch (error) {
      console.error(`Redis HGET error for ${hash}:${field}:`, error);
      return null;
    }
  }

  public async hset<T>(hash: string, field: string, value: T, options?: CacheOptions): Promise<boolean> {
    try {
      const fullHash = this.buildKey(hash, options?.prefix);
      const serializedValue = JSON.stringify(value);

      await this.redis.hset(fullHash, field, serializedValue);

      if (options?.ttl) {
        await this.redis.expire(fullHash, options.ttl);
      }

      return true;
    } catch (error) {
      console.error(`Redis HSET error for ${hash}:${field}:`, error);
      return false;
    }
  }

  public async hgetall<T>(hash: string, options?: CacheOptions): Promise<Record<string, T>> {
    try {
      const fullHash = this.buildKey(hash, options?.prefix);
      const hashData = await this.redis.hgetall(fullHash);

      const result: Record<string, T> = {};
      for (const [field, value] of Object.entries(hashData)) {
        result[field] = JSON.parse(value);
      }

      this.stats.hits++;
      return result;
    } catch (error) {
      console.error(`Redis HGETALL error for ${hash}:`, error);
      return {};
    }
  }

  // List operations
  public async lpush<T>(key: string, values: T[], options?: CacheOptions): Promise<boolean> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const serializedValues = values.map(v => JSON.stringify(v));

      await this.redis.lpush(fullKey, ...serializedValues);

      if (options?.ttl) {
        await this.redis.expire(fullKey, options.ttl);
      }

      return true;
    } catch (error) {
      console.error(`Redis LPUSH error for key ${key}:`, error);
      return false;
    }
  }

  public async lrange<T>(key: string, start: number = 0, stop: number = -1, options?: CacheOptions): Promise<T[]> {
    try {
      const fullKey = this.buildKey(key, options?.prefix);
      const values = await this.redis.lrange(fullKey, start, stop);

      return values.map(value => JSON.parse(value));
    } catch (error) {
      console.error(`Redis LRANGE error for key ${key}:`, error);
      return [];
    }
  }

  // Cache invalidation patterns
  public async invalidatePattern(pattern: string): Promise<number> {
    try {
      const keys = await this.redis.keys(pattern);
      if (keys.length === 0) return 0;

      await this.redis.del(...keys);
      return keys.length;
    } catch (error) {
      console.error(`Redis pattern invalidation error for ${pattern}:`, error);
      return 0;
    }
  }

  public async invalidateTenant(tenantId: string): Promise<number> {
    return this.invalidatePattern(`tenant:${tenantId}:*`);
  }

  public async invalidateUser(userId: string): Promise<number> {
    return this.invalidatePattern(`user:${userId}:*`);
  }

  // Cache warming
  public async warmCache(patterns: string[]): Promise<void> {
    console.log('🔥 Warming cache for patterns:', patterns);
    // Implementation depends on specific use cases
  }

  // Statistics and monitoring
  public async getStats(): Promise<CacheStats> {
    try {
      const info = await this.redis.info('memory');
      const keyspace = await this.redis.info('keyspace');
      const dbinfo = await this.redis.dbsize();

      const memoryMatch = info.match(/used_memory:(\d+)/);
      const memory = memoryMatch ? parseInt(memoryMatch[1]) : 0;

      const totalRequests = this.stats.hits + this.stats.misses;
      const hitRate = totalRequests > 0 ? (this.stats.hits / totalRequests) * 100 : 0;

      return {
        hits: this.stats.hits,
        misses: this.stats.misses,
        keys: dbinfo,
        memory,
        hitRate: Math.round(hitRate * 100) / 100
      };
    } catch (error) {
      console.error('Redis stats error:', error);
      return {
        hits: this.stats.hits,
        misses: this.stats.misses,
        keys: 0,
        memory: 0,
        hitRate: 0
      };
    }
  }

  public resetStats(): void {
    this.stats.hits = 0;
    this.stats.misses = 0;
  }

  // Health check
  public async healthCheck(): Promise<boolean> {
    try {
      const result = await this.redis.ping();
      return result === 'PONG';
    } catch (error) {
      console.error('Redis health check failed:', error);
      return false;
    }
  }

  // Utility methods
  private buildKey(key: string, prefix?: string): string {
    const basePrefix = process.env.REDIS_PREFIX || 'contacts';
    const fullPrefix = prefix ? `${basePrefix}:${prefix}` : basePrefix;
    return `${fullPrefix}:${key}`;
  }

  // Cleanup
  public async disconnect(): Promise<void> {
    await this.redis.disconnect();
  }

  public async flushall(): Promise<boolean> {
    try {
      await this.redis.flushall();
      return true;
    } catch (error) {
      console.error('Redis flush error:', error);
      return false;
    }
  }
}

export const redisService = RedisService.getInstance();